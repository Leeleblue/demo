/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 *
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
(function() {
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');

  Math.uuid = function (len, radix) {
    var chars = CHARS, uuid = [], i;
    radix = radix || chars.length;

    if (len) {
      // Compact form
      for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
    } else {
      // rfc4122, version 4 form
      var r;

      // rfc4122 requires these characters
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';

      // Fill in random data.  At i==19 set the high bits of clock sequence as
      // per rfc4122, sec. 4.1.5
      for (i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random()*16;
          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
        }
      }
    }

    return uuid.join('');
  };

  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance
  // by minimizing calls to random()
  Math.uuidFast = function() {
    var chars = CHARS, uuid = new Array(36), rnd=0, r;
    for (var i = 0; i < 36; i++) {
      if (i==8 || i==13 ||  i==18 || i==23) {
        uuid[i] = '-';
      } else if (i==14) {
        uuid[i] = '4';
      } else {
        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
        r = rnd & 0xf;
        rnd = rnd >> 4;
        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
      }
    }
    return uuid.join('');
  };

  // A more compact, but less performant, RFC4122v4 solution:
  Math.uuidCompact = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    });
  };
})();



function Kuzzle(socketUrl) {
  var
    subscribedRooms = {};
  
  if (!socketUrl || socketUrl === '') {
    console.error('Url to Kuzzle can\'t be empty');
    return false;
  }

  if (!(this instanceof Kuzzle)) {
    return new Kuzzle(socketUrl);
  }

  this.socket = io(socketUrl);

  /**
   * Subscribe to a filter
   * @param {String} collection
   * @param {Object} filters
   * @param {Function} callback
   */
  this.subscribe = function(collection, filters, callback) {
    var roomId = Math.uuid();

    // subscribe to feedback and map to callback function when receive a message :
    this.socket.once(roomId, function(response) {
      if (response.error) {
        console.error(response.error);
        return false;
      }

      subscribedRooms[roomId] = response.result;
      this.socket.off(response.result);
      this.socket.on(response.result, function(data){
        callback(data);
      });
    }.bind(this));

    // create the feedback room :
    this.socket.emit('subscribe', {
      requestId: roomId,
      action: 'on',
      collection: collection,
      body: filters
    });

    return roomId;
  };

  /**
   * Unsubscribe to a room
   * @param {String} roomId
   */
  this.unsubscribe = function(roomId) {
    if (!subscribedRooms[roomId]) {
      return false;
    }
    
    // Unsubscribes from Kuzzle & closes the socket
    this.socket.emit('subscribe', {
      requestId: roomId,
      action: 'off'
    });
    
    this.socket.off(subscribedRooms[roomId]);
    
    delete subscribedRooms[roomId];
  };

  /**
   * Write message to kuzzle
   * @param {String} collection
   * @param {String} action
   * @param {Object} body
   * @param {Boolean} persist
   * @param {Function} callback
   */
  this.write = function(collection, action, body, persist, callback) {
    var requestId = Math.uuid();

    if (callback) {
      this.socket.once(requestId, function(response) {
        callback(response);
      });
    }

    if (persist === undefined) {
      persist = false;
    }

    this.socket.emit('write', {
      requestId: requestId,
      action: action,
      persist: persist,
      collection: collection,
      body: body
    });
  };

  /**
   * Shortcut for access to the write controller and create a new document
   * @param {String} collection
   * @param {Object} body
   * @param {Boolean} persist
   * @param {Function} callback
   */
  this.create = function (collection, body, persist, callback) {
    this.write(collection, 'create', body, persist, callback);
  };

  /**
   * Shortcut for access to the write controller and update a new document
   * @param {String} collection
   * @param {Object} body
   * @param {Function} callback
   */
  this.update = function (collection, body, callback) {
    this.write(collection, 'update', body, true, callback);
  };

  /**
   * Shortcut for access to the write controller and delete a document by its id
   * @param {String} collection
   * @param {Object} id
   * @param {Function} callback
   */
  this.delete = function (collection, id, callback) {
    var body = {
      _id: id
    };

    this.write(collection, 'delete', body, true, callback);
  };

  /**
   * Shortcut for access to the write controller and delete documents by query
   * @param {String} collection
   * @param {Object} filters
   * @param {Function} callback
   */
  this.deleteByQuery = function (collection, filters, callback) {
    this.write(collection, 'deleteByQuery', filters, true, callback);
  };

  /**
   * Search document from Kuzzle according to a filter
   * @param {String} collection
   * @param {Object} data
   * @param {Function} callback
   */
  this.search = function(collection, data, callback) {
    this.readWithQuery(collection, data, 'search', callback);
  };

  /**
   * Get specific document from Kuzzle by id
   * @param {String} collection
   * @param {String} id
   * @param {Function} callback
   */
  this.get = function (collection, id, callback) {
    var requestId = Math.uuid();

    this.socket.once(requestId, function(response) {
      callback(response);
    });

    this.socket.emit('read', {
      requestId: requestId,
      action: 'get',
      collection: collection,
      _id: id
    });
  };

  /**
   * Count document from Kuzzle for a specific filter
   * @param {String} collection
   * @param {Object} filters
   * @param {Function} callback
   */
  this.count = function (collection, filters, callback) {
    var requestId = Math.uuid();

    this.socket.once(requestId, function(response) {
      callback(response);
    });

    this.socket.emit('read', {
      requestId: requestId,
      action: 'count',
      collection: collection,
      body: filters
    });
  };

  this.readWithQuery = function (collection, data, action, callback) {
    var requestId = Math.uuid();

    this.socket.once(requestId, function(response) {
      callback(response);
    });

    var object = {
      requestId: requestId,
      action: action,
      collection: collection
    };

    if (Object.keys(data).length > 1) {
      var attr;

      for(attr in data) {
        if (data.hasOwnProperty(attr)) {
          object[attr] = data[attr];
        }
      }
    }
    else {
      object.body = data;
    }

    this.socket.emit('read', object);
  }
}